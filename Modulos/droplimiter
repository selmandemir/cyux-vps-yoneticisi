#!/bin/bash
# Kullanıcı limitlerinin saklandığı veritabanı dosyasının yolu.
database="/root/usuarios.db"
# Bu script'in process ID'sini (PID) geçici bir dosyaya yaz.
echo $$ > /tmp/pids

# --- FONKSİYON: Aktif Dropbear bağlantılarını ve kullanıcılarını listeler ---
fun_drop () {
    # Dropbear'ın çalıştığı portu bul.
    port_dropbear=`ps aux | grep dropbear | awk NR==1 | awk '{print $17;}'`
    log=/var/log/auth.log
    loginsukses='Password auth succeeded' # Sistem loglarındaki başarılı giriş metni
    clear
    # Dropbear'a ait tüm aktif process ID'lerini (PID) bul.
    pids=`ps ax |grep dropbear |grep " $port_dropbear" |awk -F" " '{print $1}'`
    for pid in $pids; do
        pidlogs=`grep $pid $log |grep "$loginsukses" |awk -F" " '{print $3}'`
        i=0
        for pidend in $pidlogs; do
            let i=i+1
        done
        if [ $pidend ]; then
            # Log dosyasından kullanıcı adı, PID ve giriş zamanını çek.
            login=`grep $pid $log |grep "$pidend" |grep "$loginsukses"`
            PID=$pid
            user=`echo $login |awk -F" " '{print $10}' | sed -r "s/'/ /g"`
            waktu=`echo $login |awk -F" " '{print $2"-"$1,$3}'`
            # Çıktıyı düzgün formatlamak için boşluk ekle.
            while [ ${#waktu} -lt 13 ]; do waktu=$waktu" "; done
            while [ ${#user} -lt 16 ]; do user=$user" "; done
            while [ ${#PID} -lt 8 ]; do PID=$PID" "; done
            # Formatlanmış bilgiyi yazdır.
            echo "$user $PID $waktu"
        fi
    done
} 

# Eğer kullanıcı veritabanı dosyası yoksa hata ver ve çık.
if [ ! -f "$database" ]; then
    echo "◇ /root/usuarios.db dosyası bulunamadı!"
    exit 1
fi

# --- ANA DÖNGÜ: Kullanıcıları sürekli olarak izler ---
while true; do
    clear
    # Başlık metnini yeşil arka plan üzerine beyaz ve kalın olarak yazdır.
    echo -e "\E[42;1;37m        ㅤ🐉ㅤDROPBEAR BAĞLANTI SINIRLAYICIㅤ🐉ㅤ         \E[0m"
    echo -e "\E[42;1;37m◇Kullanıcı                               ◇Bağlantı¦Limit\E[0m"
    
    # Veritabanındaki her bir kullanıcı için döngü başlat.
    while read usline; do
        user="$(echo $usline | cut -d' ' -f1)"
        s2ssh="$(echo $usline | cut -d' ' -f2)" # Kullanıcının izin verilen limiti
        s3drop="$(fun_drop | grep "$user" | wc -l)" # Kullanıcının anlık bağlantı sayısı
        
        if [ -z "$user" ]; then
            # Boş satırları atla.
            echo "" > /dev/null
        else
            # Kullanıcının fazla bağlantılarının PID'lerini geçici bir dosyaya yaz.
            fun_drop | grep "$user" | awk '{print $2}' |cut -d' ' -f2 > /tmp/userpid
            sed -n '2 p' /tmp/userpid > /tmp/tmp2 # Sadece limiti aşan ikinci ve sonraki bağlantıyı al
            rm /tmp/userpid
            
            # Kullanıcı adını ve (anlık bağlantı / limit) durumunu ekrana yazdır.
            tput setaf 3 ; tput bold ; printf '  %-35s%s\n' $user $s3drop/$s2ssh; tput sgr0
            
            # Eğer anlık bağlantı sayısı, izin verilen limitten fazlaysa...
            if [ "$s3drop" -gt "$s2ssh" ]; then
                echo -e "\E[41;1;37m◇ Kullanıcının limiti aştığı için bağlantısı kesildi! \E[0m"
                # Limiti aşan bağlantıların PID'lerini oku ve kill komutuyla sonlandır.
                while read line; do
                    tmp="$(echo $line | cut -d' ' -f1)"
                    kill $tmp
                done < /tmp/tmp2
                rm /tmp/tmp2
            fi
        fi
    done < "$database"
    # 6 saniye bekle ve döngüyü tekrar başlat.
    sleep 6
done